# 笔试真题

#### 20190831新浪

pro1:

```
/**
 * 题目描述
 * 现有一组版本号字符串的数组，请找出里面版本号最小的值。
 * 版本号格式形如 major.minor.patch.ext，其中 major minor patch ext等都是数字。
 * 每个版本号可能点分个数不一致，大小比较按照点分数字依次从前往后，比如 7.10.2 > 7.3，3.1 > 2.3.4
 * 注意：这道题只支持java判题
 * 输入描述:
 * 一组String版本号的数组
 * 输出描述:
 * 返回最小的版本号
 * 示例1输入输出示例仅供调试，后台判题数据一般不包含示例
 * 输入
 * 3, 4.3.5.4, 2.10.3, 2.4
 * 输出
 * 2.4
 */
```

pro2:

```
/**
 * 题目描述
 * 设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put。
 *     1. 获取数据 get(key)：如果key存在于缓存中，则获取key对应的值（总是正数），否则返回 -1。
 *     2. 写入数据 put(key, value)：如果key不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
 *
 * 要求在 O(1) 的时间复杂度内完成这两个操作
 *
 * 示例:
 *         Solution cache = new Solution( 2 );
 *         cache.put(1, 1);
 *         cache.put(2, 2);
 *         cache.get(1);       // 返回  1
 *         cache.put(3, 3);   // 因为缓存容量限制，而且 1 最近有被 get，所以该操作会使得key 2 作废
 *         cache.get(2);       // 返回 -1 (未找到)
 *         cache.put(4, 4);   // 因为缓存容量限制，该操作会使得key 1 作废
 *         cache.get(1);       // 返回 -1 (未找到)
 *         cache.get(3);       // 返回  3
 *         cache.get(4);       // 返回  4
 *         注意：这道题只支持java判题
 **/
```

#### 20190901有赞

pro1：

```
/**
 * 题目描述
 * 给定一个字符串 A和一个字符串 B，求B在A中的出现次数。A和B中的字符均为英语大写字母或小写字母。
 * A中不同位置出现的B可重叠。
 * 输入描述:
 * 输入共两行，分别是字符串 A和字符串 B。
 * 输出描述:
 * 输出一个整数，表示 B在 A中的出现次数。
 * 示例1输入输出示例仅供调试，后台判题数据一般不包含示例
 * 输入
 * 复制
 * zyzyzyz
 * zyz
 * 输出
 * 复制
 * 3
 * 说明
 */
```

pro2:

```
/**
 * 题目描述
 * 在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下
 *
 * n = 3, m = 3
 * 1   2   3
 * 2   4   6
 * 3   6   9
 *
 * 给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。
 * 例如上面的例子里，
 * 从大到小为(9, 6, 6, 4, 3, 3, 2, 2, 1)
 * k = 1, v = 9
 * k = 2, v = 6
 * k = 3, v = 6
 * ...
 * k = 8, v = 2
 * k = 9, v = 1
 * 输入描述:
 * 只有一行是3个数n, m, k 表示场地的宽高和需要查询的k。使用空格隔开。
 * 输出描述:
 * 给出第k大的数的值。
 * 示例1输入输出示例仅供调试，后台判题数据一般不包含示例
 * 输入
 * 复制
 * 3 3 4
 * 输出
 * 复制
 * 4
 * 备注:
 * 【数据范围】
 * 100%的数据
 * 1 <= n, m <= 40000
 * 1 <= k <= n * m
 * 30%的数据
 * 1 <= n, m <= 1000
 */
```

pro3:

```
/**
 * 题目描述
 * 眼看着要开学了，小球觉得闲来无事，突然想来一场说走就走的旅行，呼朋唤友去游乐园玩耍，岂不快哉？
 *
 * 入园后，小球看了看游乐园的地图，发现可以将游乐园抽象成有n个景点、m条道路的无向连通图，且该图中至多有一个环（即m只可能等于n或者n-1）。小球现在所在的大门也正好是一个景点。小球不知道什么好玩，于是他决定，从当前位置出发，每次随机去一个和当前景点有道路相连的景点，并且同一个景点不去两次（包括起始景点）。贪玩的小球会一直游玩，直到当前景点的相邻景点都已经访问过为止。
 *
 * 小球所有经过的景点按顺序构成一条非重复路径，他想知道这条路径的期望长度是多少？
 *
 * 小球把游乐园的抽象地图画下来带回了家，可是忘了标哪个点是大门，他只好假设每个景点都可能是大门（即每个景点作为起始点的概率是一样的）。同时，他每次在选择下一个景点时会等概率地随机选择一个还没去过的相邻景点。
 *
 * 输入描述:
 * 第一行是两个整数n和m，分别表示景点数和道路数。 接下来行，每行三个整数Xi, Yi, Wi，分别表示第i条路径的两个景点为Xi, Yi，路径长Wi。所有景点的编号从1至n，两个景点之间至多只有一条道路。
 * 输出描述:
 * 共一行，包含一个实数，即路径的期望长度，保留五位小数。
 * 示例1输入输出示例仅供调试，后台判题数据一般不包含示例
 * 输入
 * 复制
 * 4 3
 * 1 2 3
 * 2 3 1
 * 3 4 4
 * 输出
 * 复制
 * 6.00000
 * 说明
 * 【样例解释】样例数据中共有6条不同的路径: 路径 长度 概率
 *
 * 路径 长度  概率
 * 1-->4  8   1/4
 * 2-->1  3   1/8
 * 2-->4  5   1/8
 * 3-->1  4   1/8
 * 3-->4  4   1/8
 * 4-->1  8   1/4
 *
 * 因此期望长度 = 8/4 + 3/8 + 5/8 + 4/8 + 4/8 + 8/4 = 6.00
 */
```

#### 20190901拼多多

pro1:

```
/**
 * 题目描述
 *
 * 读入一个数列和N值，返回按优先级排序的N个数，满足:
 * （1）所有偶数优先级大于奇数
 *
 * （2）同为偶数或同为奇数时，数值大的优先级高
 *
 * 输入描述:
 * 每个测试输入的测试用例，包含一个用半角逗号（,）分开的自然数数列和1个参数N，数列和参数N用半角分号（;）隔开。
 *
 * 这里保证N小于数列的元素个数（不超过100）。
 * 输出描述:
 * 在一行内输出N个满足题目条件的自然数，用逗号隔开
 * 示例1输入输出示例仅供调试，后台判题数据一般不包含示例
 * 输入
 * 555503,772867,756893,339138,399447,40662,859037,628085,855723,974471,599631,636153,581541,174761,948135,411485,554033,858627,402833,546467,574367,360461,566480,755523,222921,164287,420256,40043,977167,543295,944841,917125,331763,188173,353275,175757,950417,284578,617621,546561,913416,258741,260569,630583,252845;10
 * 输出
 * 913416,566480,420256,339138,284578,40662,977167,974471,950417,948135
 */
```

pro2：

```
/**
 * 题目描述
 * 产品经理小梅喜欢和他的男朋友小白一块玩扑克游戏。每一局，小梅抽取N张扑克牌，自左向右依次排列在桌面上；小白也抽取M（8>=N>=M>=1）张扑克牌，自左向右依次排列在桌面上。
 *
 * 小梅需要进行N个回合，使用手中的扑克牌，组成一个新的扑克牌的序列。每个回合，小梅有 d、l、r 三种策略：
 *
 * - 选择 d 时，小梅将最左边的扑克牌丢弃
 *
 * - 选择 l 时，小梅将最左边的扑克牌取出，放到新的扑克牌序列的最左边
 *
 * - 选择 r 时，小梅将最左边的扑克牌取出，放到新的扑克牌序列的最右边
 *
 * N 个回合完成，新的扑克牌序列与小白的扑克牌完全一样（只考虑数字，不考虑花色），则小梅胜出。
 *
 * 小梅向程序员小岛提了一个需求，希望了解获胜的全部方法。简化起见，扑克牌仅包含1-9。
 * 输入描述:
 * 首先，输入数字 S，作为局数（1 <= S <= 10）。
 *
 * 每一局，分别输入两行字符串，分别代表小梅的抽取的扑克牌（从左向右排列）和小白抽取到的扑克牌（从左向右排列）。
 * 输出描述:
 * 对于每一局，在开始和结束，分别输出 { 和 }。
 *
 * 输出获胜的方法，回合策略的结尾输出一个空格。若存在多个获胜方法，请按字典序的升序输出。
 * 示例1输入输出示例仅供调试，后台判题数据一般不包含示例
 * 输入
 * 复制
 * 3
 * 123
 * 3
 * 123
 * 321
 * 45
 * 67
 * 输出
 * 复制
 * {
 * d d l
 * d d r
 * }
 * {
 * l l l
 * r l l
 * }
 * {
 * }
 */
```

pro3:

```
/**
 * 题目描述
 * 扔n个骰子，第i个骰子有可能投掷出Xi种等概率的不同的结果，数字从1到Xi。所有骰子的结果的最大值将作为最终结果。求最终结果的期望。
 * 输入描述:
 * 第一行一个整数n，表示有n个骰子。（1 <= n <= 50）
 * 第二行n个整数，表示每个骰子的结果数Xi。(2 <= Xi <= 50)
 * 输出描述:
 * 输出最终结果的期望，保留两位小数。
 * 示例1输入输出示例仅供调试，后台判题数据一般不包含示例
 * 输入
 * 复制
 * 2
 * 2 2
 * 输出
 * 复制
 * 1.75
 */
```

pro4:

```
/**
 * 题目描述
 * 在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下
 *
 * n = 3, m = 3
 * 1   2   3
 * 2   4   6
 * 3   6   9
 *
 * 给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。
 * 例如上面的例子里，
 * 从大到小为(9, 6, 6, 4, 3, 3, 2, 2, 1)
 * k = 1, v = 9
 * k = 2, v = 6
 * k = 3, v = 6
 * ...
 * k = 8, v = 2
 * k = 9, v = 1
 * 输入描述:
 * 只有一行是3个数n, m, k 表示场地的宽高和需要查询的k。使用空格隔开。
 * 输出描述:
 * 给出第k大的数的值。
 * 示例1输入输出示例仅供调试，后台判题数据一般不包含示例
 * 输入
 * 复制
 * 3 3 4
 * 输出
 * 复制
 * 4
 * 备注:
 * 【数据范围】
 * 100%的数据
 * 1 <= n, m <= 40000
 * 1 <= k <= n * m
 * 30%的数据
 * 1 <= n, m <= 1000
 */
```