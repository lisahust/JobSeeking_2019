# 网易严选面经
@(面试笔试整理)

[TOC]

### 牛客网网易严选一面面经-By我的天呦真可爱
> https://www.nowcoder.com/discuss/222265?type=post&order=create&pos=&page=1
> 基本只问了Java相关的内容
> 近期做的项目有遇到什么困难吗，怎么解决的；
> Java开发中遇到问题了（比如报了异常），你一般怎么去处理；
> 就这些问题，半个小时，因为研究生期间做CV的，项目都是CV相关的，感觉没岗位相关的项目真是弱点，赶紧去网上找个项目水一下了。不确认面试官心里怎么想的，给我一次二面机会吧，有二面再回来写面经。
> 一面没有手撕代码

#### HashMap详细介绍一下，怎么计算下标值的，时间复杂度是多少，最坏的时间复杂度是多少，在扩容的时候时间复杂度是O(n)的，你有什么方式去优化这个时间复杂度吗；

##### 1. hashMap怎么计算下标值的？
HashMap使用拉链法来解决冲突，同一个链表中存在哈希值相同的Entry。hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小。

```
// hashmap
// 扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode
static final int hash(Object key) {
    int h;
    
    // 返回散列值也就是hashcode 
    // ^ ：按位异或
    // >>>:无符号右移，忽略符号位，空位都以0补齐
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

- 计算hash值：用hash(Object k)方法计算hash值
- 取模：用 `indexFor(int h, int length)` 方法中的 `h & (length-1)` 进行取模，这是位运算，它与取模运算效果是一样的，但是代价小得多。

##### 2. HashMap的时间复杂度多少？最坏的时间复杂度是多少？
HashMap的`put`和`get`评价时间复杂度都是O(1)，最差的情况是O(n)。假设由于过度碰撞将HashMap转换为链表，所以get必须搜索整个链表，所以最差的情况是O(n)。类似put的最差情况也是O(n)。O(n) + O(n) = O(2n) ==> O(n)

```
public void addOccurence(String word) { 
    if (hm.containsKey(word)){
          hm.put(word, hm.get(word)+1);
    }
    else {hm.put(word, 1); }
}
```

##### 3. 在扩容的时候时间复杂度是O(n)的，你有什么方式去优化这个时间复杂度吗？
扩容的时候时间复杂度是O(n)，因为原数组中的数据必须重新计算其在新数组中的位置，并放进去。jdk1.8之后resize()的改进：**JDK1.8使用的是2次幂的扩展。不需要重新计算索引，且迁移新表后数据不会倒置。不需要重新计算hash，只需要用原来的hash值，加上高一位做为索引。**我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，**JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置**，但是从上图可以看出，JDK1.8不会倒置。JDK1.7使用的是头插法。JDK1.8使用的是尾插法。

##### 4. 针对HashMap中某个Entry链太长，查找的时间复杂度可能达到O(n)，如何优化？
如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）。
如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表。

##### 5. 考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？
当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。


#### ConcurrentHashMap的底层实现原理，怎么查找的的，如何保证查找时的线程安全性？

##### 1. ConcurrentHashMap的底层实现原理
- JDK1.7中，ConcurrentHashMap采用了数组+Segment+分段锁的方式实现。Segment即类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（**Segment继承了ReentrantLock**）。ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。
- JDK1.8中，synchronized+CAS+HashEntry+红黑树。放弃了Segment转而采用的是**Node**。Node保存key，value及key的hash值的数据结构。现调整为对每个数组元素（Node）加锁。

##### 2. ConcurrentHashMap怎么查找的？
- JDK1.7中，ConcurrentHashMap定位一个元素的过程需要进行**两次Hash操作**。第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。
- JDK1.8中，从原来的遍历链表O(n)，变成遍历红黑树O(logN)。

#####3. ConcurrentHashMap如何保证查找时的线程安全性？
- JDK1.7中，ConcurrentHashMap是分段并发分段进行读取数据的。**Segment 里面有一个Count 字段**，用来表示当前Segment中元素的个数 它的类型是volatile变量。所有的操作到最后都会 在最后一部更新count 这个变量，由于volatile变量 happer-before的特性。导致get 方法能够几乎准确的获取最新的结构更新。
- JDK1.8中，锁住的是一个node，而不是一个segment。锁住Node之前的操作是基于在volatile和CAS之上无锁并且线程安全的。CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。**更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。**


#### 多线程介绍一下，如果一个方法被synchronized修饰了，你有什么方法可以去掉这个关键字，保证线程安全并且可以提升效率吗；

##### 1. 说一下多线程
每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。**多线程是指在同一程序中有多个顺序流在执行。**在java中要想实现多线程，有两种手段，一种是**继承Thread类**，另外一种是**实现Runable接口**.(其实准确来讲，应该有三种，还有一种是**实现Callable接口**，并与Future、线程池结合使用。

##### 2. 如果一个方法被synchronized修饰了，你有什么方法可以去掉这个关键字，保证线程安全并且可以提升效率吗？
使用synchronized关键字修饰代码块。同步代码块范围要小点，一般同步的范围越大，性能就越差，一般需要加锁进行同步的时候，肯定是范围越小越好，这样性能更好。
同步代码块是并发的时候锁定一个代码块只能一个线程占用，同步方法是对方法的锁定，如果能同步代码块尽量不要同步方法，否则影响效率。


#### 线程池介绍一下，常用的拒绝策略有哪些；

##### 1. 介绍一下线程池
为了避免重复的创建线程，线程池的出现可以让线程进行复用。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。

##### 2. 介绍一下线程池的六个参数
1. corePoolSize：核心线程数
  * 核心线程会一直存活，及时没有任务需要执行
  * 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理
  * 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭

2. queueCapacity：任务队列容量（阻塞队列）
  * 当核心线程数达到最大时，新任务会放在队列中排队等待执行

3. maxPoolSize：最大线程数
  * 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
  * 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常

4. keepAliveTime：线程空闲时间
        * 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
        * 如果allowCoreThreadTimeout=true，则会直到线程数量=0

5. allowCoreThreadTimeout：允许核心线程超时

6. rejectedExecutionHandler：任务拒绝处理器

##### 3. 线程池常用的拒绝策略有哪些？
1. ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。
2. ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务


#### 线程池中一般设置多少线程，你是怎么设定的，为什么？

##### 线程池中一般设置多少线程？
我们不应该在代码中固定线程池的大小，而应该通过某种配置机制提供，或者根据 Runtime.availableProcess() 来动态计算。
- CPU密集型时，任务可以少配置线程数，大概和机器的cpu核数相当，这样可以使得每个线程都在执行任务。在有N 个处理器的系统上，当线程池的大小为 N+1 时，能实现 CPU 的最优利用率。
- IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数


#### 线程中常用阻塞队列有哪些，你一般用哪个，LinkedBlockingQueue与ArrayBlockingQueue的优缺点对比；

##### 1. 线程中常用阻塞队列有哪些？
阻塞队列一般有五个实现类：比较常用的是ArrayBlockingQueue，LinkedBlockingQueue。
- ArrayBlockingQueue：
- LinkedBlockingQueue：
- PriorityBlockingQueue：优先级阻塞队列
- SynchronousQueue：
- DelayQueue：延时队列

##### 2. LinkedBlockingQueue与ArrayBlockingQueue的优缺点对比
- ArrayBlockingQueue其实是一个**数组有界队列**，此队列按照先进先出的原则维护数组中的元素顺序，看源码可知，是由两个整形变量（上文提到的putIndex和takeIndex）分别指着头和尾的位置。
- LinkedBlockingQueue是**基于链表的阻塞队列**，内部维持的数据缓冲队列是由链表组成的，也是按照先进先出的原则。这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。
- ArrayBlockingQueue在put,take操作使用了**同一个锁**，两者操作不能同时进行，而LinkedBlockingQueue使用了**不同的锁**，put操作和take操作可同时进行。
- ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时**不会产生或销毁任何额外的对象实例**，而后者则会**生成一个额外的Node对象**，这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。


#### JVM的CMS介绍一下，CMS重新标记时标记什么，为什么这么标记，标记待回收垃圾和标记保留对象的区别是什么，哪个更好一些；

##### 1. JVM的CMS介绍一下
并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器（Concurrent Low Pause Collector）或低延迟（low-latency）垃圾收集器；

1. 初始标记：标记老年代中所有的GC Roots引用的对象，标记老年代中被年轻代中活着的对象引用的对象。
2. 并发标记：从初始化标记阶段找到的GC Roots开始进行Tracing，找到所有的存活对象。
3. 重新标记：标记在并发标记阶段引用发生变化的对象，如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。
4. 并发清除：移除那些不同的对象，并回收占用的内存空间。

cms只会回收老年代和永久带（1.8开始为元数据区，需要设置CMSClassUnloadingEnabled），不会收集年轻带；cms是一种预处理垃圾回收器，它不能等到old内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以cms垃圾回收器开始执行回收操作，有一个触发阈值，默认是老年代或永久带达到92%；

##### 2. CMS重新标记时标记什么，为什么这么标记
标记在**并发标记阶段引用发生变化的对象**，如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。

##### 3. 标记待回收垃圾和标记保留对象的区别是什么？哪个更好一些？
1. 引用计数算法
    java在运行时，当有一个地方引用该对象实例，会将这个对象实例加1，引用失效时就减1，jvm在扫描内存时，发现引用计数值为0的则是垃圾对象，计数值大于0的则为活跃对象。 目前垃圾回收算法，没有采用引用计数算法，原因是在对象互相引用的情况下，无法判定两者是否为垃圾对象。

2. **根搜索算法 （可达性分析法）**
    根搜索算法是以“GC ROOTS”为起始点往下搜索，所有经过的对象合并起来称为引用链，在这引用链里，没有的对象称为垃圾对象，在引用链里的是活跃对象。


----------


### 牛客网网易严选一面面经-By喜欢唱跳rap的坤坤和能能
> https://www.nowcoder.com/discuss/223219?type=all&order=time&pos=&page=1
> 面试官人很好，问的都是java基础以及多线程方面的问题

#### Object继承时需要覆盖哪些方法，如何覆盖，需要注意什么

##### 1. Object继承时需要覆盖哪些方法
1. equals()：自反性、对称性、传递性、一致性。

2. hashCode()

3. toString():建议所有子类重写该方法。默认的格式是类名+“@”+哈希码值的无符号16进制表示

4. clone()


#### 设计模式了解哪些，分别说一说，是否了解外观模式，适配器模式，工厂模式

##### 1. 设计模式有哪些？
按照设计模式的目的进行划分，现有的设计模式可以分为创建型、结构型和行为型三种模式。设计模式具有适应需求变化的优点。

- **创建型模式：**abstractfactory抽象工厂模式、builder构造器模式、factorymethod工厂方法模式、prototype原型模式、singleton单例等，
- **结构型模式**：adaptor适配器模式、bridge桥接模式、composite组合模式、decorator装饰器模式、facade外观模式、flyweight享元模式和proxy代理模式，
- **行为型模式：**chain of responsibility责任链、command命令模式、interpreter解释器模式、iterator迭代器模式、mediator中介者模式、memento备忘录模式、observer观察者模式、state状态模式、strategy策略模式、template method模板方法、visitor访问者模式等。

##### 2. 讲述一下外观模式（结构型模式）
- 意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- 主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
- 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。
- 如何解决：客户端不与系统耦合，外观类与系统耦合。
- 关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。

##### 3. 讲述一下适配器模式（结构型模式）
适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能.

- 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- 主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
- 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）
- 如何解决：继承或依赖（推荐）。
- 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。

##### 4. 讲述一下工厂模式（创建型模式）
java有三种工厂模式：简单工厂模式、工厂方法模式、抽象工厂模式、

- 简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类


- 工厂模式的定义：不同品牌的汽车是由不同的工厂生产的，貌似又是很完美的。但大家看一下测试类，当一个人想要去买一辆宝马汽车的时候（假设没有销售商），那么他就要去找宝马工厂给他生产一辆，过几天又想要买一辆奔驰汽车的时候，又得跑到奔驰工厂请人生产，这无疑就增加了用户的操作复杂性。所以有没有一种方便用户操作的方法呢？这个时候抽象工厂模式就出现了。
  - 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
  - 主要解决：主要解决接口选择的问题。
  - 何时使用：我们明确地计划不同条件下创建不同实例时。
  - 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
  - 关键代码：创建过程在其子类执行。

- 抽象工厂的定义：用户需要一辆汽车，只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的生产工厂，方便用户操作。
  意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
  - 主要解决：主要解决接口选择的问题。
  - 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
  - 如何解决：在一个产品族里面，定义多个产品。
  - 关键代码：在一个工厂里聚合多个同类产品。



##### 5. 讲述一下单例模式（创建型模式）
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

- 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 主要解决：一个全局使用的类频繁地创建与销毁。
- 何时使用：当您想控制实例数目，节省系统资源的时候。
- 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
- 关键代码：构造函数是私有的

```java
// SingleObject.java
public class SingleObject {
 
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //让构造函数为 private，这样该类就不会被实例化
   private SingleObject(){}
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
 
   public void showMessage(){
      System.out.println("Hello World!");
   }
}
```

```
// SingletonPatternDemo.java
public class SingletonPatternDemo {
   public static void main(String[] args) {
 
      //不合法的构造函数
      //编译时错误：构造函数 SingleObject() 是不可见的
      //SingleObject object = new SingleObject();
 
      //获取唯一可用的对象
      SingleObject object = SingleObject.getInstance();
 
      //显示消息
      object.showMessage();
   }
}
```


#### 线程池有哪些，工作原理，有哪些饱和策略，线程池饱和了怎么排查

##### 1. Java里的线程池有哪些，工作原理是啥？
1. newCachedThreadPool创建一个**可缓存线程池程**
    newCachedThreadPool,是一种线程数量不定的线程池，并且其**最大线程数为Integer.MAX_VALUE**，这个数是很大的，一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。但是线程池中的空闲线程都有超时限制，这个超时时长是60秒，超过60秒闲置线程就会被回收。调用execute将重用以前构造的线程(如果线程可用)。这类线程池比较适合执行**大量的耗时较少的任务**，当整个线程池都处于闲置状态时，线程池中的线程都会超时被停止。

2. newFixedThreadPool 创建一个**定长线程池**
    newFixedThreadPool 创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，当线程 处于空闲状态时，它们并不会被回收，除非线程池被关闭了，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列（没有大小限制）中。由于newFixedThreadPool只有核心线程并且这些核心线程不会被回收，这样它更加快速底相应外界的请求。

3. newScheduledThreadPool 创建一个**定长线程池**
    newScheduledThreadPool 创建一个线程池，它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收，它可安排给定延迟后运行命令或者定期地执行。这类线程池主要用于执行**定时任务和具有固定周期的重复任务**。

4. newSingleThreadExecutor 创建一个**单线程化的线程池**
    newSingleThreadExecutor这类线程池内部只有**一个核心线程**，以无界队列方式来执行该线程，这使得这些任务之间不需要处理线程同步的问题，它确保所有的任务都在同一个线程中按顺序中执行，并且可以在任意给定的时间不会有多个线程是活动的。

##### 2. 使用线程池的优点
1. 重用线程池的线程，避免因为线程的创建和销毁锁带来的性能开销
2. 有效控制线程池的最大并发数，避免大量的线程之间因抢占系统资源而阻塞
3. 能够对线程进行简单的管理，并提供一下特定的操作如：可以提供定时、定期、单线程、并发数控制等功能

##### 3. 线程池有哪些饱和策略？
JDK提供了几种不同的RejectedExecutionHandler实现，每种都是不同的饱和策略：AbortPolicy,CallerRunsPolicy,DiscardPolicy和DiscardOldestPolicy.

1. AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。
2. DiscardPolicy：也是丢弃任务，但是不抛出异常。
3. DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
4. CallerRunsPolicy：由调用线程处理该任

##### 4. 线程池饱和了怎么排查？

#### 多线程相关

##### 1. 怎么创建多线程？
1. 继承Thread类
- 定义一个继承Thread类的子类，并重写该类的run()方法；
- 创建Thread子类的实例，即创建了线程对象；
- 调用该线程对象的start()方法启动线程。

2. 实现Runnable接口
- 定义Runnable接口的实现类，并重写该接口的run()方法；
- 创建Runnable实现类的实例，并以此实例作为Thread的target对象，即该Thread对象才是真正的线程对象

3. 通过Callable和Future创建线程
- 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
- 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
- 使用FutureTask对象作为Thread对象的target创建并启动新线程。
- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

##### 2. 线程的生命周期？
1. 新建
    用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。

2. 就绪
    处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。

3. 运行
    处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。

4. 阻塞
    处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。 

5. 死亡
    当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 



#### SpringMVC有哪些常用注解，框架中用到了哪些设计模式

##### 1. SpringMVC有哪些常用注解？
- 组件型注解：
- `@Component` 在类定义之前添加@Component注解，他会被spring容器识别，并转为bean。
- `@Repository` 对Dao实现类进行注解 (特殊的@Component)
- `@Service` 用于对业务逻辑层进行注解， (特殊的@Component)
- `@Controller` 用于控制层注解 ， (特殊的@Component)

- 请求和参数型注解：
- `@RequestMapping`：用于处理请求地址映射，可以作用于类和方法上。
- `@RequestParam`：用于获取传入参数的值
- `@PathViriable`：用于定义路径参数值
- `@ResponseBody`：作用于方法上，可以将整个返回结果以某种格式返回，如json或xml格式。
- `@ModelAttribute`：用于把参数保存到model中，可以注解方法或参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session（前提时要有@SessionAttributes注解） 或模型属性中
- `@SessionAttributes`：默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。配合@ModelAttribute("user")使用的时候,会将对应的名称的model值存到session中，

##### 2. SpringMVC中用到了哪些设计模式？
- 控制反转（IOC）和依赖注入（DI）
  首先声明这不是一个设计模式，而是一个原则。Spring IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
> 控制翻转怎么理解呢? 举个例子："对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中"。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转了，这就是控制反转名字的由来。

- 工厂设计模式
  Spring使用工厂模式可以通过 `BeanFactory` 或 `ApplicationContext` 创建 bean 对象。

- 单例设计模式
  在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。Spring中bean的默认作用域就是singleton(单例)的。**Spring通过ConcurrentHashMap实现单例注册表的特殊方式实现单例模式。**

- 代理设计模式
  AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
  Spring AOP就是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理

- 模板方法
  模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。
  Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。

- 观察者模式
  观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。**Spring 事件驱动模型**就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。

- 适配器模式
  Spring AOP 的增强或通知(Advice)使用到了适配器模式.
  在Spring MVC中，**DispatcherServlet** 根据请求信息调用 **HandlerMapping**，解析请求对应的 **Handler**。解析到对应的 **Handler**（也就是我们平常说的 **Controller** 控制器）后，开始由**HandlerAdapter** 适配器处理。**HandlerAdapter** 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。
  为什么要在 Spring MVC 中使用适配器模式？ Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断

----------


### 网易严选提前批一面面经-By牛客网 无口

> 作者：无口 链接：https://www.nowcoder.com/discuss/222742?type=all&order=time&pos=&page=1 来源：牛客网
> 问了一些在腾讯实习的东西。
> k8s上怎么做的RPC
> 虚拟ip不是会变吗？怎么找到服务的？
> 你们有尝试过Service Mesh之类的东西吗？不敢多说。。。
> 讲个熟悉的数据结构

#### HashMap讲一下原理以及使用场景， 红黑树为什么要在长度为8再变，ConcurrentHashMap的使用场景以及原理

##### 1. HashMap讲一下原理以及使用场景
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。

##### 2. 红黑树为什么要在长度为8再变
TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。

不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是拍拍屁股决定的，而是根据概率统计决定的。

##### 3. 说说你对红黑树的见解
1. 每个节点非红即黑
2. 根节点总是黑色的
3. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
4. 每个叶子节点都是黑色的空节点（NIL节点）
5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）

##### 4. ConcurrentHashMap的使用场景以及原理
1. JDK1.7的ConcurrentHashMap：
- 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。
- ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。
- Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。

```
static class Segment<K,V> extends ReentrantLock implements Serializable {
}
```

- 一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，**一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素**，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。

2. JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：

- ConcurrentHashMap取消了Segment分段锁，采用**CAS和synchronized**来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）
  **synchronized只锁定当前链表或红黑二叉树的首节点**，这样只要hash不冲突，就不会产生并发，效率又提升N倍


#### 讲讲MySQL的索引、mysql的常用引擎、MySQL的事务类型

##### 1. MySQL的索引有哪些？
1. 普通索引
    这是最基本的索引，它没有任何限制。

2. 唯一索引
    索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

3. 主键索引
    是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引

4. 全文索引
    全文索引（FULLTEXT）仅可以适用于MyISAM引擎的数据表；作用于CHAR、VARCHAR、TEXT数据类型的列。

5. 多列索引/组合索引
    将几个列作为一条索引进行检索，使用最左匹配原则。

##### 2. 说一下mysql的常用引擎？
MySQL主要有8种存储引擎：
| 存储引擎	| 特征
| -------- | --------
| MyISAM	| 高速引擎，不支持事务处理
| InnoDB	| 支持行锁定以及事务处理，速度比MyISAM稍慢
| ISAM	| MyISAM的前身
| MERGE	| 将多个MyISAM类型的表作为一个表来处理的引擎
| MEMORY,HEAP	| 只在内存上保存数据
| Falcon	| 一种新的存储引擎，支持事务处理
| ARCHIVE	| 将数据压缩后保存（只能支持INSERT/SELECT操作
| CSV	| 以CSV形式保存数据（应用于跨平台数据交换）



1. InnoDB：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理**大数据容量的数据库系统**。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是**不支持全文搜索**，同时启动也比较的慢，它是**不会保存表的行数**的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，**写操作是不会锁定全表**的,所以在并发度较高的场景下使用会提升效率。这种类型**事务安全，支持外键；表格速度快，具有事务，回滚和崩溃修复能力**；提供行锁。InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。第一个重大区别是**InnoDB的数据文件本身就是索引文件**。第二个与MyISAM索引的不同是**InnoDB的辅助索引data域存储相应记录主键的值而不是地址**。

2. MyIsAM：**MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。**因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM引擎是保存了表的行数，于是当进行 select count(*)from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，**如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。**MyISAM引擎使用B+Tree作为索引结构，叶结点的data域存放的是数据记录的地址。

##### 3. 说一下数据库的事务隔离/MySQL的事务类型
- READ-UNCOMMITTED：**未提交读**，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。
- READ-COMMITTED：**提交读**，一个事务提交后才能被其他事务读取到（会造成幻读、不可重读）。
- REPEATABLE-READ：**可重复读**，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。
- SERIALIZABLE：**序列化**，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。

##### 4. JAVA连接数据库的过程
1. 加载驱动类，注册驱动
2. 通过DrivrManager获取数据库连接
3. 通过connection创建statement
4. 通过statement执行sql语句，返回结果集
5. 操作resultSet结果集
6. 回收数据库资源，晚声明的先关


#### Spring是怎么支持事务的,为什么@Transation注解修饰的方法可以在多线程的方式下互不影响,Connection是存在什么样的数据结构上的

##### 1. Spring是怎么支持事务的
Spring事务的本质是**对数据库事务的封装支持**，没有数据库对事务的支持，**Spring本身无法提供事务管理功能**。对于用JDBC操作数据库想要用到事务，必须经过**获取连接 -> 开启事务 -> 执行CRUD操作 -> 提交/回滚事务 -> 关闭连接**几部分操作。使用Spring管理事务后，可以省掉自己写代码开启、提交/回滚事务的操作。


##### 2. 为什么@Transation注解修饰的方法可以在多线程的方式下互不影响
Spring 就是使用`ThreadLocal`来存储`Connection`的，不同的线程Connection肯定不一样，所以不可能会在同一个事务中。

##### 3. Connection是存在什么样的数据结构上的（不知道啊！！！！！！！！！！！）
Spring 就是使用`ThreadLocal`来存储`Connection`.s

##### 4. java是怎么连接数据库的？
```
package com.runoob.test;
import java.sql.*;
 
public class MySQLDemo {
 
    // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL
    static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";  
    static final String DB_URL = "jdbc:mysql://localhost:3306/RUNOOB";
 
    // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL
    //static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";  
    //static final String DB_URL = "jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&serverTimezone=UTC";
 
    // 数据库的用户名与密码，需要根据自己的设置
    static final String USER = "root";
    static final String PASS = "123456";
 
    public static void main(String[] args) {
        Connection conn = null;
        Statement stmt = null;
        try{
            // 注册 JDBC 驱动
            Class.forName(JDBC_DRIVER);
        
            // 打开链接
            System.out.println("连接数据库...");
            conn = DriverManager.getConnection(DB_URL,USER,PASS);
        
            // 执行查询
            System.out.println(" 实例化Statement对象...");
            stmt = conn.createStatement();
            String sql;
            sql = "SELECT id, name, url FROM websites";
            ResultSet rs = stmt.executeQuery(sql);
        
            // 展开结果集数据库
            while(rs.next()){
                // 通过字段检索
                int id  = rs.getInt("id");
                String name = rs.getString("name");
                String url = rs.getString("url");
    
                // 输出数据
                System.out.print("ID: " + id);
                System.out.print(", 站点名称: " + name);
                System.out.print(", 站点 URL: " + url);
                System.out.print("\n");
            }
            // 完成后关闭
            rs.close();
            stmt.close();
            conn.close();
        }catch(SQLException se){
            // 处理 JDBC 错误
            se.printStackTrace();
        }catch(Exception e){
            // 处理 Class.forName 错误
            e.printStackTrace();
        }finally{
            // 关闭资源
            try{
                if(stmt!=null) stmt.close();
            }catch(SQLException se2){
            }// 什么都不做
            try{
                if(conn!=null) conn.close();
            }catch(SQLException se){
                se.printStackTrace();
            }
        }
        System.out.println("Goodbye!");
    }
}
```


#### 分布式锁用过吗？用Redis怎么实现

实现分布式锁的方式有很多，只要满足上述条件的都可以实现分布式锁，比如数据库，**redis**，**zookeeper**。

#### Redis集群怎么搭？怎么分片的？


#### CAS知道吗？原理是怎么样的？CAS有哪些使用场景？CAS线程安全吗？有什么问题？除了线程安全呢？对于CPU呢？

##### 1. 什么是CAS？
在计算机科学中，比较和交换（Conmpare And Swap）是用于实现多线程同步的原子指令。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。 操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成（摘自维基本科）

##### 2. CAS的原理是什么？
CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。

##### 3. CAS有哪些使用场景？
CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。JAVA中大多的原子操作都是基于CAS的。

##### 4. CAS线程安全吗？有什么问题？除了线程安全呢？对于CPU呢？


#### Atomic在高并发场景下有什么问题，缺点？


#### 用过Dubbo吗？稍微讲一下
#### Paxos算法稍微讲一下
#### ZooKeeper最少要几个节点，为什么？


#### 了解哪些开源的组件


#### CAP知道吗？大概讲一讲
C代表一致性（Consistency），A代表可用性（Availability），P代表分区容错性（Partition Tolerance）。

----------


### 网易严选一面面经-By秋招offer快快来

> 作者：秋招offer快快来 链接：https://www.nowcoder.com/discuss/222631?toCommentId=3492037 来源：牛客网
> 1. 自我介绍
> 2. 分布式锁怎么做？
> 3. SpringBoot的自动配置如何加载的
> 4. Spring的AOP的应用场景和原理
> 5. Redis的设计思路，这么设计的好处是什么？Redis Cluster用过吗？
> 6. Redis的底层数据结构
> 7. MySQL的ACID是什么，怎么保证的
> 8. 索引的类型，为什么使用B+树作为索引的数据结构
> 9. 覆盖索引了解吗？
> 10. 类是如何加载的？如何设计一个类加载器
> 11. 为什么要用线程池？
> 12. 单核cpu有必要使用线程池吗？
> 13. Java中的锁机制是如何实现的？有什么区别
> 14. Java如何实现线程间的同步
> 15. 有什么想问的


#### 分布式锁怎么做？
分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”
实现分布式锁的方式有很多，只要满足上述条件的都可以实现分布式锁，比如数据库，**redis**，**zookeeper**。
> 分布式锁如何实现 https://blog.csdn.net/u012415035/article/details/82113532

- 基于**数据库**实现分布锁：
  在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

- 选用**Redis**实现分布式锁原因：
1. Redis有很高的性能； 
2. Redis命令对此支持较好，实现起来比较方便

- **ZooKeeper**是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：
1. 创建一个目录mylock； 
2. 线程A想获取锁就在mylock目录下创建临时顺序节点； 
3. 获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； 
4. 线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； 
5. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

#### SpringBoot的自动配置如何加载的
> Spring Boot面试杀手锏————自动配置原理 https://blog.csdn.net/u014745069/article/details/83820511

Spring Boot的启动类上有一个 `@SpringBootApplication` 注解，这个注解是Spring Boot项目必不可少的注解。
其中， `@ComponentScan` 将扫描和加载一些自定义的类， `@EnableAutoConfiguration` 将导入一些自动配置的类。这些自动配置的类很多，并且他们都处于`org.springframework.boot.autoconfigure`这个包下面。这些配置类都会被导入并处于备用状态。

#### Spring的AOP的应用场景和原理

##### 1. AOP使用场景
- Authentication 权限
- Caching 缓存
- Context passing 内容传递
- Error handling 错误处理
- Lazy loading　懒加载
- Debugging　　调试
- logging, tracing, profiling and monitoring　记录跟踪　优化　校准
- Performance optimization　性能优化
- Persistence　　持久化
- Resource pooling　资源池
- Synchronization　同步
- Transactions 事务

#### Redis的设计思路，这么设计的好处是什么？Redis Cluster用过吗？
#### Redis的底层数据结构


#### MySQL的ACID是什么，怎么保证的

##### 1. MySQL的ACID是什么？
- 原子性 （Atomicity）
  原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。

- 隔离性   (Isolation)
  隔离性是指多个事务并发执行的时候，**事务内部的操作与其他事务是隔离的**，并发执行的各个事务之间不能互相干扰。

- 持久性   (Durability)
  持久性是指事务一旦提交，**它对数据库的改变就应该是永久性的**。接下来的其他操作或故障不应该对其有任何影响。

- 一致性  (Consistency)
  一致性是指**事务执行前后，数据处于一种合法的状态**，这种状态是语义上的而不是语法上的。 这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！

##### 2. MySQL怎么保持ACID的？
1. 怎么保持一致性？
    数据库必须要实现AID三大特性，才有可能实现一致性。

2. 怎么保持原子性？
    利用Innodb的**undo log**。 undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。

3. 怎么保持持久性？
    利用Innodb的**redo log**（重做日志）。事务提交前直接把数据写入磁盘。

4. 怎么保持隔离性？
    利用的是**锁和MVCC机制**。


#### 索引的类型，为什么使用B+树作为索引的数据结构？覆盖索引了解吗？


##### 1. 索引的类型有哪些？

##### 2. 为什么使用B+树作为索引的数据结构？
B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。

B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中。

1. **B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2. **B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3. **由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可**，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

##### 3. 覆盖索引了解吗？
mysql可以使用索引来直接获取列的数据。如果索引的叶子节点包含了要查询的数据，那么就不用回表查询了，也就是说这种索引包含（亦称覆盖）所有需要查询的字段的值，我们称这种索引为覆盖索引。
MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后再去查询数据，所以那是相当的快!!但是同时也要求所查询的字段必须被索引所覆盖到，在Explain的时候，输出的Extra信息中如果有“Using Index”，就表示这条查询使用了覆盖索引。

##### 4. select poll epoll的区别
1. Select  poll每次循环调用时，都需要将描述符和事件拷贝到内核空间；epoll只需要拷贝一次；
    这种情况在对于描述符数量不大的情况下还可以，但是当描述符的数量达到十几万甚至上百万的时候，他们的效率就会急速降低，因为每一次轮询都需要将这些所有的socket描述符从用户态拷贝到内核态，会造成大量的浪费和资源开销；

2. Select  poll每次返回后，需要遍历所有描述符才能找到就绪的，因此他两的时间复杂度为o(n),而epoll则只需要O(1);

3. Select poll内核是通过轮询的方式完成，时间复杂度为O(N);epoll是在每个描述符上设置回调函数，时间复杂度为O(1)


#### 类是如何加载的？如何设计一个类加载器

##### 1. java8之前的类加载器
1. **启动类加载器（Bootstrap Class-Loader）**，加载jre/lib下面的jar文件，如rt.jar。它是个超级公民，即使是在开启了Security Manager的时候，JDK仍赋予了它加载的程序AllPermission。
2. **扩展类加载器（Extension or Ext Class-Loader）**，负责加载我们放到jre/lib/ext目录下面的jar包，这就是所谓的extension机制。该目录也可以通过设置“java.ext.dirs”来覆盖。
3. **应用类加载器（Application or App Class-Loader）**，就是加载我们最熟悉的classpath的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是JDK內建的应用类加载器，但是它同样是可能修改的

##### 2. 如何设计一个类加载器
实现自定义类加载有以下两步：
1、继承ClassLoader
2、重写findClass，在findClass里获取类的字节码，并调用ClassLoader中的defineClass方法来加载类，获取class对象。


####  为什么要用线程池？单核cpu有必要使用线程池吗？

##### 1. 为什么要使用线程池？
为了减少创建和销毁线程的次数，让每个线程可以多次使用,可根据系统情况调整执行的线程数量，防止消耗过多内存,所以我们可以使用线程池.

##### 2. 单核cpu有必要使用线程池吗？
一般没有必要的话，尤其在单核CPU的时候，不推荐使用多线程。


#### Java中的锁机制是如何实现的？有什么区别？Java如何实现线程间的同步？

##### 1. Java中的锁机制是如何实现的？
1. synchronized：
- synchronized是一种**互斥锁**,一次只能允许一个线程进入被锁住的代码块.
- synchronized保证了线程的**原子性**。synchronized还保证了**可见性**。
- **防止竞争** 保证某些代码同时只有一个线程执行，防止由于竞争导致逻辑出错
- **内存可见性** 即获取锁时，线程会将本地缓存无效，从主内存中获取最新的数据；释放锁时，会将本地缓存刷新到主内存中，保证其他线程看到最新的数据。

2. 显式Lock
- Lock方式来获取锁支持中断、超时不获取、是非阻塞的
- **提高了语义化**，哪里加锁，哪里解锁都得写出来
- Lock显式锁可以给我们带来很好的灵活性，但同时我们必须手动释放锁
- 支持Condition条件对象
- 允许多个读线程同时访问共享资源
- 要**手动释放锁**

##### 2. Java中的两种锁机制有什么区别？
1. 首先synchronized是**java内置关键字**，在jvm层面，Lock是个**java类**；
2. synchronized**无法判断是否获取锁的状态**，Lock**可以判断是否获取到锁**；
3. synchronized会**自动释放锁**(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中**手工释放锁**（unlock()方法释放锁），否则容易造成线程死锁；
4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就**不一定会等待下去**，如果尝试获取不到锁，线程可以不用一直等待就结束了；
5. synchronized的锁**可重入、不可中断、非公平**，而Lock锁**可重入、可判断、可公平**（两者皆可）
6. Lock锁适合**大量同步的代码的同步问题**，synchronized锁适合**代码少量的同步问题**。

----------


### 网易严选一面面经-By布鲁斯韦恩是蝙蝠侠

> 作者：布鲁斯韦恩是蝙蝠侠 链接：https://www.nowcoder.com/discuss/223146?type=post&order=hot&pos=&page=1 来源：牛客网
> 1.自我介绍
> 2.项目介绍以及细节
> 3.kafka消息丢失怎么办？
> 4.说一下Java内存模型
> 5.Java内存模型如何保证一致性？
> 6.说一下Mysql索引有哪些
> 7.B+树索引怎么实现的
> 8.B+树索引和哈希索引都有什么优缺点？B+树和B树区别是什么？为什么用B+树实现索引
> 9.用过ThreadLocal吗，怎么实现的？ThreadLocalMap怎么保证线程安全的？
> 10.写一个LRU
> 11.说一下zookeeper
> 12.有什么问题要问？
> 总时长30分钟左右，第一次面试很紧张，很多没答好。。。面试官比较和善

#### 说一下Java内存模型。Java内存模型如何保证一致性？

##### 1. Java程序具体执行的过程：
- Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)；
- 由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行；
- 在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存；
- 因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

##### 2. JVM的内存划分和各区域职责：
- 程序计数器：程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令
- **Java栈**：Java栈是Java方法执行的内存模型，Java栈中存放的是一个个的栈帧，每个栈帧（包括：局部变量表、操作数栈、运行时常量池（在下文中提到的方法区内）的引用、方法返回地址和一些额外的附加信息）对应一个被调用的方法，当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈；
- 本地方法栈：Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的
- **堆**：Java中的堆是用来存储对象本身的以及数组；
- 方法区：它与堆一样，是被线程共享的区域，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

##### 3. Java内存模型如何保证一致性？
多线程环境下，有哪些一致性问题？
1. CPU缓存导致的：缓存与内存数据的一致性问题；
2. 指令重排序导致的：指令真正被执行顺序与程序书写的顺序的一致性问题；

我们通过一些方法来禁止CPU缓存和禁止指令重排序。


#### 垃圾回收机制的算法

##### 1. 垃圾回收机制的算法
1. 标记清除：缺点 1）产生大量不连续的内存碎片 2）标记和清除效率都不高
2. 复制：它将可用内存按照容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，则就将还存活的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。
3. 标记整理：标记过程和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清除，而是让 all 存活对象都向一端移动，然后直接清理掉端边界以外的内存。
4. 分代回收：新生代 停止-复制算法 ，老年代 标记-清理或标记-清除

##### 2. 垃圾收集器
垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别。

- 新生代收集器：Serial、ParNew、Parallel Scavenge；
- 老年代收集器：Serial Old、Parallel Old、CMS；
- 整堆收集器：G1；

##### 3. 讲讲垃圾收集器-CMS
并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器（Concurrent Low Pause Collector）或低延迟（low-latency）垃圾收集器；

1. 初始标记：标记老年代中所有的GC Roots引用的对象，标记老年代中被年轻代中活着的对象引用的对象。
2. 并发标记：从初始化标记阶段找到的GC Roots开始进行Tracing，找到所有的存活对象。
3. 重新标记：标记在并发标记阶段引用发生变化的对象，如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。
4. 并发清除：移除那些不同的对象，并回收占用的内存空间。

cms只会回收老年代和永久带（1.8开始为元数据区，需要设置CMSClassUnloadingEnabled），不会收集年轻带；cms是一种预处理垃圾回收器，它不能等到old内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以cms垃圾回收器开始执行回收操作，有一个触发阈值，默认是老年代或永久带达到92%；

##### 4. 讲讲垃圾收集器-G1
1. 分代： CMS中，堆被分为PermGen，YoungGen，OldGen；而YoungGen又分了两个survivo区域。在G1中，堆被平均分成几个区域(region)，在每个区域中，虽然也保留了新老代的概念，但是收集器是以整个区域为单位收集的。 
2. 算法： 相对于CMS的“标记——清理”算法，G1会使用压缩算法，保证不产生多余的碎片。收集阶段，G1会将某个区域存活的对象拷贝的其他区域，然后将整个区域整个回收。 
3. 停顿时间可控： 为了缩短停顿时间，G1建立可预存停顿模型，这样在用户设置的停顿时间范围内，G1会选择适当的区域进行收集，确保停顿时间不超过用户指定时间。

#### 写一个LRU
整体的设计思路是，可以使用 HashMap 存储 key，这样可以做到 save 和 get key的时间都是 O(1)，而 HashMap 的 Value 指向双向链表实现的 LRU 的 Node 节点.


#### 说一ZooKeeper
> Zookeeper入门看这篇就够了 https://blog.csdn.net/java_66666/article/details/81015302

##### ZooKeeper的分布锁应用
- **ZooKeeper**是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：
1. 创建一个目录mylock； 
2. 线程A想获取锁就在mylock目录下创建临时顺序节点； 
3. 获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； 
4. 线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； 
5. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

----------


### 网易严选二面java-byWorldweekend

> 40min 作者：Worldweekend 链接：https://www.nowcoder.com/discuss/227512?type=post&order=hot&pos=&page=1 来源：牛客网
> 1.介绍一下自己。
> 2.介绍一下项目。
> 3.刚才你说的，数据库隔离方案是怎么设计的。
> 4.多租户场景下的单个数据库资源占用过多怎么解决？
> 5.mycat分库分表了解吗？原理说一下。
> 6.分布式事务，两阶段提交，三阶段提交。
> 7.Spring的事务隔离模式。
> 8.在一个事务A方法里调另一个事务B方法，映射到mysqlA和B两个事务，这两个事务可以并存吗？
> 9.int类型在32位和64位的环境下，长度有什么不同？
> 10.你刚才说到java内存模型，详细说一下。
> 11.volatile关键字修饰的变量可以放到寄存器里面吗？
> 12.Java本身可以自动解决死锁问题吗？
> 13.mysql可以解决吗？怎么解决的？
> 14.redis高可用怎么搭建的。
> 15.Redis集群负载均衡怎么搭建？
> 16.RPC通信框架的概念。
> 17.RPC通信的流程。
> 18.你刚才说到服务注册中心有负载均衡的作用，它底层是怎么实现的？
> 19.Docker怎么实现资源隔离的。
> 20.单点登录怎么实现的？
> 21.存放登录状态的Redis服务器挂了怎么办？
> 22.Spring Bean的生命周期。
> 23.什么是Spring的声明式事务管理。

#### Spring事务

##### 1. 事务的API介绍一下？
Spring事务管理高层抽象主要包括3个接口：`PlatformTransactionManager`（事务管理器）、`TransactionDefinition` （事务定义信息）、`TransactionStatus` （事务状态）

##### 2. 讲一下Java的事务管理器。

Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给 `Hibernate` 或者 `JTA` 等持久化机制所提供的相关平台框架的事务来实现。

Spring事务管理器的接口是 `org.springframework.transaction.PlatformTransactionManager` ，通过这个接口，`Spring` 为各个平台如 `JTA` 、`JDBC` 、 `Hibernate` 、`JPA` 等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。 为 `JDBC` 提供的事务管理器是 `DataSourceTransactionManager` ，为 `Hibernate` 提供的事务管理器是 `HibernateTransactionManager` ， 为 `JPA(JAVA持久化API事务)` 提供的事务管理器是 `JpaTransactionManager ` 。如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用 `JtaTransactionManager`  。

##### 3. 事务隔离模式说一下。

1. 脏读：一个事物读取了另一个事物改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。 
2. 不可重复读：不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。 
3. 幻读：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。 

##### 4. 在一个事务A方法里调另一个事务B方法，映射到mysqlA和B两个事务，这两个事务可以并存吗？

在一个Service内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都**不会开启新的事务**.是因为spring采用动态代理机制来实现事务控制，而动态代理最终都是要调用原始对象的，而原始对象在去调用方法时，是不会再触发代理了！

##### 5. 事务的实现方式有哪些？

1. 编程式事务管理：通过TransactionTemplate手动管理事物，与业务耦合度高，很少使用，略。 
2. 声明式事务管理：Spring的声明式事务是通过**AOP**实现的。 

#### 引用内存、操作系统相关

##### 对象头、数组对象的对象头、引用大小分别占多大内存？

**对象头**在32位系统上占用8bytes，64位系统上占用16bytes。  

**引用的大小**跟操作系统有关，操作系统是64位的，就8字节，32位就4字节。

64位机器上，**数组对象的对象头**占用24个字节，启用压缩之后占用16个字节。 

- 未开启压缩：24（对象头）+8*3【】=48，不需要padding； 

#### Spring Bean的生命周期

##### 1. Bean实例生命周期的执行过程？

- Spring对bean进行实例化，默认bean是单例；
- Spring对bean进行依赖注入；
- 如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；
- 如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；
- 如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；
- 如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；
- 如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；
- 如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；
- 此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；
- 若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；


----------

### 网易严选提前批二面java-by无口

> 作者：无口 链接：https://www.nowcoder.com/discuss/228265 来源：牛客网 
> 介绍实习的工作
> 为什么k8s以pod为基本单位，不以container为基本单位
> 同一pod下的container资源隔离吗？他们是怎么通信的。
> statefulset是怎么保证过程中状态的有序性的
> 你觉得ingress有什么缺陷
> istio部署后对于不同的ingress有什么影响
> push模式和pull模式比较？
> 生产环境中Prometheus怎么发现新建的pod的信息的？
> 线程越多越好吗？怎么保证对线程资源的有效利用性？
> 阿姆达尔定律听说过吗？没有。。。
> Long和Double线程安全吗
> 异步线程池里面每一个Task怎么保证他们的上下文不丢失
> Spring的事务，Connection对象的生命周期，Spring是怎么和数据库以及ORM框架对接的？
> 线程在运行过程中可以手动停止吗？
> 怎么优雅的停止JVM的一个线程？
> kill -9 和 kill -10 的区别
> kill -9 和 kill -10 的区别
> 假设有两个很大的数组，每个几万条数据，如何快速求交集？

#### 线程相关

##### 1. 线程越多越好吗？怎么保证对线程资源的有效利用性？

多线程的应用不是为了提高运行效率，而是为了**提高资源使用效率**。比如你的应用程序需要访问网络，因为网络有延时，如果在界面线程访问，那么在网络访问期间界面将无法响应用户消息，这是就应该使用多线程。  **采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。** 上述结果只是针对单CPU，如果对于多CPU或者CPU采用超线程技术的话，采用多线程技术还是会提高程序的执行速度的。因为单线程只会映射到一个CPU上，而多线程会映射到多个CPU上，超线程技术本质是多线程硬件化，所以也会加快程序的执行速度。 

##### 阿姆达尔定律听说过吗？
阿姆达尔（Amdahl）定律描述的是：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组建与串行组件所占的比重。S=1/(1-a+a/n)  其中，a为并行计算部分所占比例，n为并行处理结点个数。

##### 2. 有一个线程池关于IO阻塞时间计算的xxxx公式听说过吗？

- Ncpu=CPU的数量
- Ucpu=目标CPU使用率
- W/C=等待时间与计算时间的比率

为保持处理器达到期望的使用率，最优的线程池的大小等于

```
Nthreads=Ncpu*Ucpu*（1+W/C）
其中Ncpu可以通过  Runtime.getRuntime().availableProcessors() 获取
```

##### 3. 线程在运行过程中可以手动停止吗？

停止一个线程可以用Thread.stop()方法，但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且是已被废弃的方法。 在java中有以下3种方法可以终止正在运行的线程：

1. 使用**退出标志**，使线程正常退出，也就是**当run方法完成后线程终止**。`public volatile boolean flag = true;`  定义一个标志位，在run方法中判断。
2. 使用**stop方法强行终止**，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。调用stop()方法时会抛出`java.lang.ThreadDeath`异常 。
3. 使用**interrupt方法中断线程**：在Run方法中 `catch (InterruptedException e)` 
4. `thread.interrupt();`  相当于打了一个标记，再做  `if(this.isInterrupted())`  + `return` 判断。

##### 4. 线程池里面每一个Task怎么保证他们的上下文不丢失

CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，**从任务保存到再加载的过程就是一次上下文切换**。 为什么有时候并发执行的速度会比串行慢呢？这就是因为**线程有创建和上下文切换的开销** 

对于我们经常使用的抢占式操作系统而言，引起线程上下文切换的原因大概有以下几种：

1. 当前执行任务的时间片用完之后，系统CPU正常调度下一个任务
2. 当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务
3. 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务
4. 用户代码挂起当前任务，让出CPU时间
5. 硬件中断

##### 5. 如何减少上下文切换

既然上下文切换会导致额外的开销，因此减少上下文切换次数便可以提高多线程程序的运行效率。减少上下文切换的方法有**无锁并发编程**、**CAS算法**、**使用最少线程**和**使用协程**。

- **无锁并发编程**。多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据
- **CAS算法**。Java的Atomic包使用CAS算法来更新数据，而不需要加锁
- **使用最少线程**。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态
- **协程**。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

#### Long和Double线程安全吗

由于规范没有规定如何实现，那么当今所知的虚拟机对这条规则的实现都是把32位值做为原子性对待，而不是64位做为原子性。那么，当线程把主存中的long/double类型的值读到线程内存中时，可能是两次32位值的写操作，显而易见，如果几个线程同时操作，那么就可能会出现高低2个32位值出错的情况发生，所以现在，java程序必须确保通过同步来操作共享的long和double。 

#### kill -9 和 kill -10 的区别？

默认参数下，kill 发送 `SIGTERM` （15）信号给进程，告诉进程，**你需要被关闭，请自行停止运行并退出**。 kill -9 发送 `SIGKILL` 信号给进程，告诉进程，**你被终结了，请立刻退出**。 因此 kill - 9 表示**强制杀死该进程**；与SIGTERM相比，这个信号不能被捕获或忽略，同时接收这个信号的进程在收到这个信号时不能执行任何清理。  kill -10 发送 SIGUSER1  **用户自定义信号**  给进程，并进程终止 。

----------


### 网易严选提前批java二面-byjooooon

> 作者：jooooon 链接：https://www.nowcoder.com/discuss/228609?type=post&order=time&pos=&page=1 来源：牛客网
> 先问实习：
> 架构
> 微服务划分、调用
> 微服务之间的服务发现等等
> 说问的太深了哦，换个话题😶
> 问项目
> 针对项目提出了几个场景问题
> Spring AOP (动态代理、***等等)
> Spring bean的生命周期（问了一些具体的实现，懵）
> 怎么停止JVM的一个线程？
> 因为提了kill所以问 kill -9 /kill -15
> 平常会用到哪些技术？xxx
> 问了GC mysql表 JVM的优化分析 问了一个没听过的技术🤣
> 了解分布式么?
> 等等
> 问的东西常规，但是角度很奇特，大概就是你用过才会的那种 🤣

#### Spring

##### 1. Spring AOP (动态代理、*等等) 
##### 2. Spring bean的生命周期（问了一些具体的实现，懵） 

----------


### 网易严选场景题

##### 假设有两个很大的数组，每个几万条数据，如何快速求交集？ 


